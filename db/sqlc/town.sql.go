// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: town.sql

package db

import (
	"context"
)

const createTown = `-- name: CreateTown :one
INSERT INTO towns (
    town_name,
    town_desc,
    district_id
) VALUES (
 $1, $2, $3
)
RETURNING id, town_name, town_desc, district_id
`

type CreateTownParams struct {
	TownName   string `json:"town_name"`
	TownDesc   string `json:"town_desc"`
	DistrictID int64  `json:"district_id"`
}

func (q *Queries) CreateTown(ctx context.Context, arg CreateTownParams) (Town, error) {
	row := q.db.QueryRow(ctx, createTown, arg.TownName, arg.TownDesc, arg.DistrictID)
	var i Town
	err := row.Scan(
		&i.ID,
		&i.TownName,
		&i.TownDesc,
		&i.DistrictID,
	)
	return i, err
}

const deleteTown = `-- name: DeleteTown :exec
DELETE FROM towns
WHERE id = $1
`

func (q *Queries) DeleteTown(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTown, id)
	return err
}

const getTown0 = `-- name: GetTown0 :one
SELECT id, town_name, town_desc, district_id FROM towns
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTown0(ctx context.Context, id int64) (Town, error) {
	row := q.db.QueryRow(ctx, getTown0, id)
	var i Town
	err := row.Scan(
		&i.ID,
		&i.TownName,
		&i.TownDesc,
		&i.DistrictID,
	)
	return i, err
}

const getTown1 = `-- name: GetTown1 :one
SELECT id, town_name, town_desc, district_id FROM towns
WHERE town_name = $1 LIMIT 1
`

func (q *Queries) GetTown1(ctx context.Context, townName string) (Town, error) {
	row := q.db.QueryRow(ctx, getTown1, townName)
	var i Town
	err := row.Scan(
		&i.ID,
		&i.TownName,
		&i.TownDesc,
		&i.DistrictID,
	)
	return i, err
}

const listTowns = `-- name: ListTowns :many
SELECT id, town_name, town_desc, district_id FROM towns
WHERE district_id = $3
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListTownsParams struct {
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
	DistrictID int64 `json:"district_id"`
}

func (q *Queries) ListTowns(ctx context.Context, arg ListTownsParams) ([]Town, error) {
	rows, err := q.db.Query(ctx, listTowns, arg.Limit, arg.Offset, arg.DistrictID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Town{}
	for rows.Next() {
		var i Town
		if err := rows.Scan(
			&i.ID,
			&i.TownName,
			&i.TownDesc,
			&i.DistrictID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTown = `-- name: UpdateTown :one
UPDATE towns
SET town_name = $2,
town_desc = $3,
district_id = $4
WHERE id = $1
RETURNING id, town_name, town_desc, district_id
`

type UpdateTownParams struct {
	ID         int64  `json:"id"`
	TownName   string `json:"town_name"`
	TownDesc   string `json:"town_desc"`
	DistrictID int64  `json:"district_id"`
}

func (q *Queries) UpdateTown(ctx context.Context, arg UpdateTownParams) (Town, error) {
	row := q.db.QueryRow(ctx, updateTown,
		arg.ID,
		arg.TownName,
		arg.TownDesc,
		arg.DistrictID,
	)
	var i Town
	err := row.Scan(
		&i.ID,
		&i.TownName,
		&i.TownDesc,
		&i.DistrictID,
	)
	return i, err
}
