// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: block.sql

package db

import (
	"context"
)

const createBlock = `-- name: CreateBlock :one
INSERT INTO blocks (
    block_name,
    block_desc,
    total_population,
    town_id,
    clutter_id
) VALUES (
 $1, $2, $3, $4, $5
)
RETURNING id, block_name, block_desc, total_population, town_id, clutter_id
`

type CreateBlockParams struct {
	BlockName       string `json:"block_name"`
	BlockDesc       string `json:"block_desc"`
	TotalPopulation int64  `json:"total_population"`
	TownID          int64  `json:"town_id"`
	ClutterID       int64  `json:"clutter_id"`
}

func (q *Queries) CreateBlock(ctx context.Context, arg CreateBlockParams) (Block, error) {
	row := q.db.QueryRow(ctx, createBlock,
		arg.BlockName,
		arg.BlockDesc,
		arg.TotalPopulation,
		arg.TownID,
		arg.ClutterID,
	)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BlockName,
		&i.BlockDesc,
		&i.TotalPopulation,
		&i.TownID,
		&i.ClutterID,
	)
	return i, err
}

const deleteBlock = `-- name: DeleteBlock :exec
DELETE FROM blocks
WHERE id = $1
`

func (q *Queries) DeleteBlock(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteBlock, id)
	return err
}

const getBlock0 = `-- name: GetBlock0 :one
SELECT id, block_name, block_desc, total_population, town_id, clutter_id FROM blocks
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetBlock0(ctx context.Context, id int64) (Block, error) {
	row := q.db.QueryRow(ctx, getBlock0, id)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BlockName,
		&i.BlockDesc,
		&i.TotalPopulation,
		&i.TownID,
		&i.ClutterID,
	)
	return i, err
}

const getBlock1 = `-- name: GetBlock1 :one
SELECT id, block_name, block_desc, total_population, town_id, clutter_id FROM blocks
WHERE block_name = $1 LIMIT 1
`

func (q *Queries) GetBlock1(ctx context.Context, blockName string) (Block, error) {
	row := q.db.QueryRow(ctx, getBlock1, blockName)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BlockName,
		&i.BlockDesc,
		&i.TotalPopulation,
		&i.TownID,
		&i.ClutterID,
	)
	return i, err
}

const listBlocks = `-- name: ListBlocks :many
SELECT id, block_name, block_desc, total_population, town_id, clutter_id FROM blocks
WHERE town_id = $3 OR clutter_id = $4
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListBlocksParams struct {
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
	TownID    int64 `json:"town_id"`
	ClutterID int64 `json:"clutter_id"`
}

func (q *Queries) ListBlocks(ctx context.Context, arg ListBlocksParams) ([]Block, error) {
	rows, err := q.db.Query(ctx, listBlocks,
		arg.Limit,
		arg.Offset,
		arg.TownID,
		arg.ClutterID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Block{}
	for rows.Next() {
		var i Block
		if err := rows.Scan(
			&i.ID,
			&i.BlockName,
			&i.BlockDesc,
			&i.TotalPopulation,
			&i.TownID,
			&i.ClutterID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBlock = `-- name: UpdateBlock :one
UPDATE blocks
SET block_name = $2,
block_desc = $3,
total_population = $4,
town_id = $5,
clutter_id = $6
WHERE id = $1
RETURNING id, block_name, block_desc, total_population, town_id, clutter_id
`

type UpdateBlockParams struct {
	ID              int64  `json:"id"`
	BlockName       string `json:"block_name"`
	BlockDesc       string `json:"block_desc"`
	TotalPopulation int64  `json:"total_population"`
	TownID          int64  `json:"town_id"`
	ClutterID       int64  `json:"clutter_id"`
}

func (q *Queries) UpdateBlock(ctx context.Context, arg UpdateBlockParams) (Block, error) {
	row := q.db.QueryRow(ctx, updateBlock,
		arg.ID,
		arg.BlockName,
		arg.BlockDesc,
		arg.TotalPopulation,
		arg.TownID,
		arg.ClutterID,
	)
	var i Block
	err := row.Scan(
		&i.ID,
		&i.BlockName,
		&i.BlockDesc,
		&i.TotalPopulation,
		&i.TownID,
		&i.ClutterID,
	)
	return i, err
}
